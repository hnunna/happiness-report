<!DOCTYPE html>
<html>
<meta charset="utf-8">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/css/bootstrap.min.css">
<body>
<style>
  .countries {
    /* fill: none; */
    fill-opacity: .7;
    stroke: #fff;
    stroke-linejoin: round;
  }
  .legendThreshold {
      font-size: 12px;
      font-family: sans-serif;
  }
  .caption {
      fill: #000;
      text-anchor: start;
      font-weight: bold;
  }
  .countries :hover {
    fill-opacity: .99;
  /* fill: blue; */
}
.countries :active {
  fill: red;
}
</style>
<div class="container-fluid">
    <div class="row">
        <div class="col-md-9" id="my_chart">
            <svg width="800" height="600"></svg>
        </div>
        <div class="col-md-3" id="my_pie">
        </div>
    </div>
    <!-- <div class="row">
        <button id="element" onclick="updateMap()">Click me to update</button>
        </div> -->
</div>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.24.0/d3-legend.js"></script>
<script>
var inputData = [];
var pC;
var leg;
var worldData;
// The svg
var svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = +svg.attr("height");

// Map and projection
var path = d3.geoPath();
var projection = d3.geoNaturalEarth()
    .scale(width / 2 / Math.PI)
    .translate([width / 2, height / 2])
var path = d3.geoPath()
    .projection(projection);

// Data and color scale
var data = d3.map();
var colorScale = d3.scaleThreshold()
.domain([1, 10, 30, 50, 70])
.range(['lightgrey', 'green', 'lightgreen', 'orange', 'red']);

// Legend
var g = svg.append("g")
    .attr("class", "legendThreshold")
    .attr("transform", "translate(20,20)");
g.append("text")
    .attr("class", "caption")
    .attr("x", 0)
    .attr("y", -6)
    .text("Happiness ladder");
var labels = ['Not in scope', '1-10', '10-50', '50-100', '>100'];
var legend1 = d3.legendColor()
    .labels(function (d) { return labels[d.i]; })
    .shapePadding(4)
    .scale(colorScale);
svg.select(".legendThreshold")
    .call(legend1);

var tooltip = d3.select("#my_chart")
    .append("div")
	.style("position", "absolute")
	.style("z-index", "10")
	.style("visibility", "hidden")
    .style("background-color","#D3D3D3")
    .style("border","solid thin #fff");

function mouseover(){
    tooltip.style("visibility", "visible");
}

function mousemove(d){
    var tooltipText;
    if(d.ladder > 0){
        tooltipText = "Country: " + d.properties.name + "<br />" + "Rank: " + d.ladder;
    }
    else tooltipText = "Country: " + d.properties.name;
    tooltip.html(tooltipText)
    tooltip.style("top", (event.pageY-10)+"px").style("left",(event.pageX+10)+"px");
}

function mouseout(){
    tooltip.style("visibility", "hidden");
}

function chartClicked(d,i){
    // filter for selected country based on ladder
    var st = inputData.filter(function(s){ return s.ladder == d.ladder;});
    var dataForPieChart = [];
    var attributes = ['corruption','freedom','generosity','healthyLifeExpectancy',
    'logOfGDperCapita','negativeAffect','positiveAffect','socialSupport'];
    for(var item in attributes){
        var key = attributes[item];
        if(st[0][key]){
            let newObj = {};
            newObj.type = attributes[item];
            newObj.typeValue = st[0][key];
            dataForPieChart.push(newObj);
        }
    }

    var c = {};
    c.countryName = st[0].name;
    c.ladder = st[0].ladder;
    dataForPieChart.push(c);

    pC.update(dataForPieChart);
    leg.update(dataForPieChart);
}

function segColor(c) {
     return {corruption:"#807dba", freedom:"#e08214",generosity:"#41ab5d",healthyLifeExpectancy:"#eeff00",
     logOfGDperCapita:"#ff0022",negativeAffect:"#2200ff",positiveAffect:"#8626d9",socialSupport:"#c1e9aa"}[c];
}

// Load external data and boot
d3.queue()
    .defer(d3.json, "https://enjalot.github.io/wwsd/data/world/world-110m.geojson")
    .defer(d3.csv, "happiness-data-v1.csv", function(d) {
        inputData.push(d);
        data.set(d.code, +d.ladder);
        })
    .await(ready);

function ready(error, topo) {
    if (error) throw error;
    worldData = topo.features;
    // Draw the map
    svg.append("g")
        .attr("id", "my_map")
        .attr("class", "countries")
        .selectAll("path")
        .data(topo.features)
        .enter().append("path")
            .attr("fill", function (d){
                // Pull data for this country
                d.ladder = data.get(d.id) || 0;
                // Set the color
                return colorScale(d.ladder);
            })
            .attr("d", path)
                .on("mouseover", mouseover)
                .on("mousemove", mousemove)
                .on("mouseout", mouseout)
                .on("click", chartClicked);

    var topCountryData = inputData.filter(function(s){ return s.ladder == '1.0';});

    var initialPieChartData = [];
    var attributes = ['corruption','freedom','generosity','healthyLifeExpectancy',
    'logOfGDperCapita','negativeAffect','positiveAffect','socialSupport'];
    for(var item in attributes){
        var key = attributes[item];
        if(topCountryData[0][key]){
            let newObj = {};
            newObj.type = attributes[item];
            newObj.typeValue = topCountryData[0][key];
            initialPieChartData.push(newObj);
        }
    }
    var legendData = JSON.parse(JSON.stringify(initialPieChartData));
    var c = {};
    c.countryName = topCountryData[0].name;
    c.ladder = topCountryData[0].ladder;
    initialPieChartData.push(c);

    pC = pieChart(initialPieChartData);
    leg = legend(legendData);
}

// function to handle pieChart.
function pieChart(pD){
        var pC ={},    pieDim ={w:250, h: 250};
        pieDim.r = Math.min(pieDim.w, pieDim.h) / 2;

        // create svg for pie chart.
        var piesvg = d3.select(my_pie).append("svg")
            .attr("width", pieDim.w).attr("height", pieDim.h).append("g")
            .attr("transform", "translate("+pieDim.w/2+","+pieDim.h/2+")");

        // create function to draw the arcs of the pie slices.
        var arc = d3.arc().outerRadius(pieDim.r - 10).innerRadius(pieDim.r-50);

        // create a function to compute the pie slice angles.
        var pie = d3.pie().sort(null).value(function(d) { return d.typeValue; });

        var g = piesvg.selectAll("path").data(pie(pD)).enter().append("g");
        g.append("path").attr("d", arc)
            .each(function(d) { this._current = d; })
            .style("fill", function(d) { return segColor(d.data.type); });

            g.append("text")
        .attr("id","countryText")
	    .attr("text-anchor", "middle")
		 .attr('font-size', '1em')
		 .attr('y', 2)
         .text("Country Name: "+ pD[pD.length - 1].countryName);

       g.append("text")
       .attr("id","ladderText")
	   .attr("text-anchor", "middle")
		 .attr('font-size', '1em')
		 .attr('y', 20)
         .text("Rank: "+ pD[pD.length - 1].ladder);

        // create function to update pie-chart. This will be used by histogram.
        pC.update = function(nD){
            piesvg.selectAll("path").data(pie(nD)).transition().duration(500)
                .attrTween("d", arcTween);
            piesvg.selectAll("#countryText").text("Country Name: "+ nD[nD.length - 1].countryName);
           piesvg.selectAll("#ladderText").text("Rank: "+ nD[nD.length - 1].ladder)
        }

        // Animating the pie-slice requiring a custom function which specifies
        // how the intermediate paths should be drawn.
        function arcTween(a) {
            var i = d3.interpolate(this._current, a);
            this._current = i(0);
            return function(t) { return arc(i(t));};
        }
        return pC;
    }

function legend(lD){
        var leg = {};

        // create table for legend.
        var legend = d3.select(my_pie).append("table").attr('class','legend');

        // create one row per segment.
        var tr = legend.append("tbody").selectAll("tr").data(lD).enter().append("tr");

        // create the first column for each segment.
        tr.append("td").append("svg").attr("width", '16').attr("height", '16').append("rect")
            .attr("width", '16').attr("height", '16')
			.attr("fill",function(d){ return segColor(d.type); });

        // create the second column for each segment.
        tr.append("td").text(function(d){ return d.type;});

        // create the third column for each segment.
        tr.append("td").attr("class",'legendFreq')
            .text(function(d){ return d3.format(",")(d.typeValue);});

        // Utility function to be used to update the legend.
        leg.update = function(nD){
            // update the data attached to the row elements.
            var l = legend.select("tbody").selectAll("tr").data(nD);

            // update the frequencies.
            l.select(".legendFreq").text(function(d){ return d3.format(",")(d.typeValue);});
        }

        return leg;
    }
</script>
</body>
</html>